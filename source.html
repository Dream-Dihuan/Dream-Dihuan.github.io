<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMS监考系统</title>
    <style>
        div {
            margin: 0 auto;
            /* display: flex; */
            margin: 30px 0;
        }

        #download {
            width: 300px;
            height: 200px;
            font-size: 30px;
            margin: 50px auto;
        }

        button {
            height: 50px;
            padding: 10px 10px;
            margin: 10px 0px;
        }
    </style>
</head>

<body>
    <div>
        <button id="download">下载资源</button>
    </div>

    <!-- 实战1-1 -->
    <div>
        <button class="四则计算器">四则计算器</button>
        <button class="输入三角形三条边，求面积">输入三角形三条边，求面积</button>
        <button class="三角形类别">三角形类别</button>
        <button class="猴子吃桃2">猴子吃桃2</button>
        <button class="猴子吃桃">猴子吃桃</button>
    </div>

    <!-- 实战1-2 -->
    <div>
        <button class="字符类别判断">字符类别判断</button>
        <button class="统计符合条件的数字">统计符合条件的数字</button>
        <button class="判断质数">判断质数</button>
        <button class="判断闰年">判断闰年</button>
        <button class="判断成绩的等级">判断成绩的等级</button>
        <button class="回文数个数">回文数个数</button>
        <button class="分解质因子">分解质因子</button>
    </div>

    <!-- 实战2-1 -->
    <div>
        <button class="编程求135">编程求1+3+5+...+n</button>
        <button class="编程求n的阶乘">编程求n的阶乘</button>
        <button class="汉诺塔游戏">汉诺塔游戏</button>
        <button class="猴子吃桃（扩展）">猴子吃桃（扩展）</button>
        <button class="猴子吃桃">猴子吃桃</button>
        <button class="爬楼梯（扩展）">爬楼梯（扩展）</button>
        <button class="爬楼梯">爬楼梯</button>
        <button class="求算式前n项的和">求算式前n项的和</button>
    </div>

    <!-- 实战2-2 -->
    <div>
        <button class="波兰表达式">波兰表达式</button>
        <button class="分解质因子">分解质因子</button>
        <button class="汉诺塔游戏（扩展）">汉诺塔游戏（扩展）</button>
        <button class="回文数个数">回文数个数</button>
        <button class="买汽水">买汽水</button>
        <button class="求N个数的最大公因数">求N个数的最大公因数</button>
        <button class="求倒序数">求倒序数</button>
        <button class="求两个数的最大公因数">求两个数的最大公因数</button>
        <button class="十进制转换为R进制">十进制转换为R进制</button>
    </div>

    <!-- 实战4-1 -->
    <div>
        <button class="查找">查找</button>
        <button class="单词排序">单词排序</button>
        <button class="分类统计各类字符数">分类统计各类字符数</button>
        <button class="孤独的素数">孤独的素数</button>
        <button class="交换最小值和最大值">交换最小值和最大值</button>
        <button class="数字提取">数字提取</button>
        <button class="数组逆序">数组逆序</button>
        <button class="鲜花方阵">鲜花方阵</button>
    </div>

    <!-- 实战4-2 -->
    <div>
        <button class="查找最小的K个元素">查找最小的K个元素</button>
        <button class="矩阵字符">矩阵字符</button>
        <button class="排队游戏">排队游戏</button>
        <button class="蛇形填数">蛇形填数</button>
        <button class="数列元素去重并排序">数列元素去重并排序</button>
        <button class="约瑟夫游戏111">约瑟夫游戏（编号+密码）</button>
        <button class="约瑟夫游戏（姓名）">约瑟夫游戏（姓名）</button>
        <button class="约瑟夫游戏">约瑟夫游戏</button>
        <button class="字符串移位包含问题">字符串移位包含问题</button>
    </div>

    <!-- 实战5 -->
    <div>
        <button class="排队点名">排队点名</button>
        <button class="期末考试成绩排名">期末考试成绩排名</button>
        <button class="新生舞会">新生舞会</button>
        <button class="约瑟夫游戏222">约瑟夫游戏（序号+姓名+密码）</button>
    </div>
</body>
<script>
    //下载代码包
    document.querySelector('#download').addEventListener('click', () => {
        // 定义要下载的文件的URL
        const fileUrl = 'https://dihuan.site/document.rar';

        // 使用fetch API下载文件
        fetch(fileUrl)
            .then(response => {
                // 将响应转换为blob对象
                return response.blob();
            })
            .then(blob => {
                // 创建一个URL对象，指向blob
                const blobUrl = window.URL.createObjectURL(blob);

                // 创建一个 <a> 元素
                const link = document.createElement('a');

                // 设置<a>元素的href属性为blob URL
                link.href = blobUrl;

                // 设置<a>元素的download属性为要保存的文件名
                link.download = 'document.rar';

                // 将<a>元素添加到页面中
                document.body.appendChild(link);

                // 模拟点击<a>元素来触发下载
                link.click();

                // 清理URL对象
                window.URL.revokeObjectURL(blobUrl);
            })
            .catch(error => {
                console.error('下载文件时出错：', error);
            });
    })

    //实战1-1
    document.querySelector('.四则计算器').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

double num1, num2;
char op;

void read_number() {
    scanf("%lf %c %lf", &num1, &op, &num2);
}

void calculate() {
    switch (op) {
        case '+':
            printf("%.2lf", num1 + num2);
            break;
        case '-':
            printf("%.2lf", num1 - num2);
            break;
        case '*':
            printf("%.2lf", num1 * num2);
            break;
        case '/':
            if (num2 < 1e-10 && num2 > -1e-10) {
                printf("Wrong input!");
            } else {
                printf("%.2lf", num1 / num2);
            }
            break;
        default:
            printf("Wrong input!");
            break;
    }
}

int main() {
    read_number();
    calculate();
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.输入三角形三条边，求面积').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <math.h>

int l[3], total = 0;
double p, area;

int check() {
    if (l[0] + l[1] > l[2] && l[2] + l[1] > l[0] && l[0] + l[2] > l[1]) {
        return 1;
    } else {
        return 0;
    }
}

int main() {
    for (int i = 0; i < 3; i++) {
        scanf("%d", &l[i]);
        total += l[i];
    }
    if (!check()) {
        printf("error");
        return 0;
    }
    p = total / 2.0;
    area = sqrt(p * (p - l[0]) * (p - l[1]) * (p - l[2]));
    printf("%.2f", area);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.三角形类别').addEventListener('click', () => {
        const textToCopy = `#include<stdio.h>
int main()
{
    int a,b,c,d,e,f;
    int g=0;
    scanf("%d %d %d",&a,&b,&c);
    if(a+b<c){
        g=1;
        printf("no");
    }
    if(a+c<b){
        g=1;
        printf("no");
    }
    if(b+c<a){
        g=1;
        printf("no");
    }
    if(g==0){
    d=a*a+b*b-c*c;
    e=b*b+c*c-a*a;
    f=c*c+a*a-b*b;
    if(d==0)
        printf("zhijiao");
    else if(e==0)
        printf("zhijiao");
    else if(f==0)
        printf("zhijiao");
    if(d<0)
        printf("dunjiao");
    else if(e<0)
        printf("dunjiao");
    else if(f<0)
        printf("dunjiao");
    printf("ruijiao");
    }
    return 0;
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.猴子吃桃2').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int main() {
    long long int day, num = 1;
    
    scanf("%lld", &day);
    
    for (int i = 1; i < day; i++) {
        num++;
        num *= num;
    }
    
    printf("%lld", num);
    
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.猴子吃桃').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int main() {
    long long int day, num = 1;
    
    scanf("%lld", &day);
    
    for (int i = 1; i < day; i++) {
        num++;
        num *= 2;
    }
    
    printf("%lld", num);
    
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })

    //实战1-2
    document.querySelector('.字符类别判断').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int main() {
    char c;
    printf("Enter a character: ");
    scanf("%c", &c);
    printf("%d ", c);
    if (c < 32) {
        printf("control");
    } else {
        if (c >= '0' && c <= '9') {
            printf("digit");
        } else {
            if (c >= 'a' && c <= 'z') {
                printf("lower case");
            } else {
                if (c >= 'A' && c <= 'Z') {
                    printf("upper case");
                } else {
                    printf("others");
                }
            }
        }
    }
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.统计符合条件的数字').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

long long int d, n, m, ans = 0, start, tmp;

void check() {
    for (int i = start; i <= m; i += d) {
        tmp = i;
        do {
            int num = tmp % 10;
            if (num == d) {
                ans++;
                break;
            }
            tmp /= 10;
        } while (tmp);
    }
}

int main() {
    scanf("%lld %lld %lld", &d, &n, &m);
    for (int i = 0; i < d; i++) {
        if ((n + i) % d == 0) {
            start = n + i;
        }
    }
    check();
    printf("%lld", ans);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.判断质数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <math.h>

long long int num1, num2;
int first = 0;

void printPrime(int tmp) {
    if (first == 0) {
        printf("%d", tmp);
        first = 1;
    } else {
        printf(" %d", tmp);
    }
}

void check(int tmp) {
    for (int i = 2; i <= sqrt(tmp); i++) {
        if (tmp % i == 0) {
            return;
        }
    }
    printPrime(tmp);
}

int main() {
    scanf("%lld", &num1);
    scanf("%lld", &num2);

    if (num1 <= num2) {
        for (int i = num1; i <= num2; i++) {
            check(i);
        }
    } else {
        for (int i = num1; i >= num2; i--) {
            check(i);
        }
    }

    if (first == 0) {
        printf("NO");
    }

    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.判断闰年').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int year1, year2, num = 0;

void check(int year)
{
	if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
	{
		if (num == 0)
		{
			printf("%d", year);
		}
		else
		{
			printf(" %d", year);
		}
		num++;
	}
}

void printAns()
{
	if (num == 0)
	{
		printf("0000\n0");
	}
	else
	{
		printf("\n%d", num);
	}
}

int main()
{
	scanf("%d", &year1);
	scanf("%d", &year2);
	if (year1 <= year2)
	{
		for (int i = year1; i <= year2; i++)
		{
			check(i);
		}
		printAns();
	}
	else
	{
		for (int i = year1; i >= year2; i--)
		{
			check(i);
		}
		printAns();
	}

	return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.判断成绩的等级').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

double score;

void judge()
{
    if (score >= 90 && score <= 100)
    {
        printf("A");
        return;
    }
    if (score >= 80 && score < 90)
    {
        printf("B");
        return;
    }
    if (score >= 70 && score < 80)
    {
        printf("C");
        return;
    }
    if (score >= 60 && score < 70)
    {
        printf("D");
        return;
    }
    if (score >= 0 && score < 60)
    {
        printf("E");
        return;
    }
    printf("ERR");
}

int main()
{
    scanf("%lf", &score);
    judge();
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.回文数个数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <string.h>

int amount = 0;

void check(int tmp) {
    char str[20];
    sprintf(str, "%d", tmp);
    int len = strlen(str);
    if (len % 2 == 0) { // 偶数位
        for (int i = 0; i < len / 2; i++) {
            if (str[i] != str[len - i - 1]) {
                return;
            }
        }
    } else {
        for (int i = 0; i < (len + 1) / 2; i++) {
            if (str[i] != str[len - i - 1]) {
                return;
            }
        }
    }
    amount++;
}

int main() {
    int num;
    scanf("%d", &num);
    for (int i = 1; i <= num; i++) {
        check(i);
    }
    printf("%d", amount);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.分解质因子').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <math.h>

long long int num;
int first = 0;

int isPrime(long long int tmp);

void calculate() {
    while (num != 1) {
        for (int i = 2; i <= num; i++) {
            if (num % i == 0) {
                if (isPrime(i) == 1) {
                    num /= i;
                    if (first == 0) {
                        printf("%d", i);
                        first = 1;
                    } else {
                        printf("*%d", i);
                    }
                    break;
                }
            }
        }
    }
}

int isPrime(long long int tmp) {
    for (int i = 2; i <= sqrt(tmp); i++) {
        if (tmp % i == 0) {
            return 0;
        }
    }
    return 1;
}

int main() {
    scanf("%lld", &num);
    printf("%lld=", num);
    calculate();
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })

    //实战2-1
    document.querySelector('.编程求135').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int n, ans = 0;

void dfs(int tmp)
{
    if (tmp == 1)
    {
        ans++;
        printf("%d", ans);
        return;
    }
    ans += tmp;
    dfs(tmp - 2);
}

int main()
{
    scanf("%d", &n);
    dfs(n);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.编程求n的阶乘').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

long long int ans = 1;

void dfs(long long int tmp) {
    if (tmp == 1) {
        printf("%lld", ans);
        return;
    }
    ans *= tmp;
    dfs(tmp - 1);
}

int main() {
    long long int n;
    scanf("%lld", &n);
    dfs(n);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.汉诺塔游戏').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int step = 0;

void hanio(int n, char A, char B, char C)
{
    if (n == 1)
    {
        printf("%c To %c\n", A, C);
        step++;
    }
    else
    {
        hanio(n - 1, A, C, B);
        printf("%c To %c\n", A, C);
        step++;
        hanio(n - 1, B, A, C);
    }
}

int main()
{
    int n;
    scanf("%d", &n);
    hanio(n, 'A', 'B', 'C');
    printf("%d\n", step);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.猴子吃桃（扩展）').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <math.h>

long long int dp(int tmp);

long long int n, ans = 1;

int main()
{
    scanf("%lld", &n);
    ans = dp(n);
    printf("%lld", ans);
    return 0;
}

long long int dp(int tmp)
{
    if (tmp == 1)
    {
        return 1;
    }
    return pow((dp(tmp - 1) + 1), 2);
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.猴子吃桃').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

long long int dp(int tmp);

int main() {
    long long int n, ans = 1;
    
    scanf("%lld", &n);
    ans = dp(n);
    printf("%lld", ans);
    
    return 0;
}

long long int dp(int tmp) {
    if (tmp == 1) {
        return 1;
    }
    return (dp(tmp - 1) + 1) * 2;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.爬楼梯（扩展）').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

long long int dp(long long int temp);

int main() {
    int n;
    long long int ans;
    
    scanf("%d", &n);
    ans = dp(n);
    printf("%lld", ans);
    
    return 0;
}

long long int dp(long long int temp) {
    if (temp == 0) {
        return 1;
    }
    if (temp < 0) {
        return 0;
    }
    return dp(temp - 1) + dp(temp - 2) + dp(temp - 3);
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.爬楼梯').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int dp(int temp) {
    if (temp == 0) {
        return 1;
    }
    if (temp < 0) {
        return 0;
    }
    return dp(temp - 1) + dp(temp - 2);
}

int main() {
    int n, ans;
    scanf("%d", &n);
    ans = dp(n);
    printf("%d", ans);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.求算式前n项的和').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

#define N 33

double Fibonacci[N], ans;
int n;

double write_Fibonacci(int tmp);
double dp(int tmp);

double write_Fibonacci(int tmp)
{
    if (tmp == 1)
    {
        Fibonacci[1] = 1;
        return 1;
    }
    if (tmp <= 0)
    {
        return 0;
    }
    return write_Fibonacci(tmp - 1) + write_Fibonacci(tmp - 2);
}

double dp(int tmp)
{
    if (tmp == 1)
    {
        return 1;
    }
    if (tmp <= 0)
    {
        return 0;
    }
    return Fibonacci[tmp] / Fibonacci[tmp + 1] + dp(tmp - 1);
}

int main() {
    scanf("%d", &n);
    for (int tmp = n; tmp >= -1; tmp--)
    {
        Fibonacci[tmp + 1] = write_Fibonacci(tmp + 1);
    }
    ans = dp(n);
    printf("%.3lf", ans);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })

    // 实战2-2
    document.querySelector('.波兰表达式').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <stdlib.h>

double exp();

double exp()
{
    char s[20];
    scanf("%s", s);
    switch(s[0])
    {
        case '+': return exp() + exp();
        case '-': return exp() - exp();
        case '*': return exp() * exp();
        case '/': return exp() / exp();
        default : return atof(s);
    }
}

int main()
{
    printf("%.5f", exp());
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.分解质因子').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <math.h>

int isPrime(int tmp) {
    for (int i = 2; i <= sqrt(tmp); i++) {
        if (tmp % i == 0) {
            return 0;
        }
    }
    return 1;
}

int dp(int tmp) {
    if (tmp == 1) {
        return 0;
    }
    for (int i = 2; i <= tmp; i++) {
        if (isPrime(i) && tmp % i == 0) {
            printf("%d ", i);
            tmp /= i;
            return dp(tmp);
        }
    }
}

int main() {
    int num;
    scanf("%d", &num);
    if (isPrime(num)) {
        printf("%d ", num);
        return 0;
    }
    dp(num);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.汉诺塔游戏（扩展）').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int step = 0;

void move(int n, char a, char b) {
    printf("%c To %c\n", a, b);
    step++;
}

void hanoi(int n, char a, char c, char b) {
    if (n > 0) {
        hanoi(n - 1, a, b, c);
        move(n, a, b);
        hanoi(n - 1, c, a, b);
        move(n, b, c);
        hanoi(n - 1, a, c, b);
    }
}

int main() {
    int n;
    char a = 'A', b = 'B', c = 'C';
    scanf("%d", &n);
    hanoi(n, a, c, b);
    printf("%d\n", step);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.回文数个数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

bool isPalindrome(char *tmp, int l, int r) {
    if (l >= r) {
        return true;
    }
    if (tmp[l] == tmp[r]) {
        l++;
        r--;
        return isPalindrome(tmp, l, r);
    } else {
        return false;
    }
}

int main() {
    long long int n, ans = 0;
    scanf("%lld", &n);
    for (long long int i = 1; i <= n; i++) {
        char tmp[20];
        sprintf(tmp, "%lld", i);
        int len = strlen(tmp);
        if (isPalindrome(tmp, 0, len - 1)) {
            ans++;
        }
    }
    printf("%lld", ans);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.买汽水').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int n, m, pingzi = 0, qishui = 0, ans = 0;

int dp(int tmp) {
    pingzi += qishui;
    qishui = 0;
    if (qishui == 0 && pingzi < 2) {
        return 0;
    }
    pingzi -= 2;
    qishui += 1;
    return dp(pingzi - 2) + 1;
}

int main() {
    scanf("%d %d", &n, &m);
    pingzi += m / n;
    ans += m / n;
    ans += dp(pingzi);
    printf("%d", ans);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.求N个数的最大公因数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

#define N 210

long long int num[N];
long long int biggest;

long long int dp(int index, int n_num)
{
    long long int cs, bcs, ys;
    bcs = biggest;
    cs = num[index];
    if (index == n_num)
    {
        return biggest;
    }
    do
    {
        ys = bcs % cs;
        bcs = cs;
        if (ys != 0)
        {
            cs = ys;
        }
    } while (ys != 0);
    biggest = cs;
    return dp(index + 1, n_num);
}

int main()
{
    int n_num, i;
    scanf("%lld", &n_num);
    for (i = 0; i < n_num; i++)
    {
        scanf("%lld", &num[i]);
    }
    biggest = num[0];
    biggest = dp(1, n_num);
    printf("%lld\n", biggest);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.求倒序数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <string.h>

int main() {
    char num[100];
    int not_first_zero = 0;

    scanf("%s", num);

    for (int i = strlen(num) - 1; i >= 0; i--) {
        if (num[i] != '0') {
            not_first_zero = 1;
        }
        if (not_first_zero == 1) {
            printf("%c", num[i]);
        }
    }

    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.求两个数的最大公因数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

long long int dp(long long int bcs, long long int cs)
{
    long long int ys;
    if (bcs % cs == 0)
    {
        return cs;
    }
    ys = bcs % cs;
    return dp(cs, ys);
}

int main()
{
    long long int bcs, cs;
    scanf("%lld %lld", &bcs, &cs);
    printf("%lld\n", dp(bcs, cs));
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.十进制转换为R进制').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <math.h>

int jinzhi, num, index = 1;
char dic[16] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
int ans[100]; // 使用数组代替vector

void dp(int tmp)
{
    if (tmp == -1)
    {
        return;
    }
    int the_one_num = 0;
    while (num >= pow(jinzhi, tmp))
    {
        num -= pow(jinzhi, tmp);
        the_one_num++;
    }
    ans[index++] = the_one_num; // 将结果存入数组中
    dp(tmp - 1);
}

void translate_print()
{
    for (int i = 1; i < index; i++) // 数组下标从1开始
    {
        printf("%c", dic[ans[i]]);
    }
}

int main()
{
    scanf("%d %d", &num, &jinzhi);
    while (pow(jinzhi, index + 1) < num)
    {
        index++;
    }
    dp(index);
    translate_print();
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })

    // 实战4-1
    document.querySelector('.查找').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>  
  
  int binarySearch(int arr[], int n, int x) {  
      int left = 0, right = n - 1;  
      while (left <= right) {  
          int mid = left + (right - left) / 2;  
          if (arr[mid] == x) {  
              return mid + 1; // 返回数组中的位置，数组索引从0开始，位置从1开始  
          } else if (arr[mid] < x) {  
              left = mid + 1;  
          } else {  
              right = mid - 1;  
          }  
      }  
      return -1; // 如果未找到，返回-1  
  }  
    
  int main() {  
      int n;  
      scanf("%d", &n);  
    
      int arr[n];  
      for (int i = 0; i < n; i++) {  
          scanf("%d", &arr[i]);  
      }  
    
      int x;  
      scanf("%d", &x);  
    
      int position = binarySearch(arr, n, x);  
      printf("%d\n", position);  
    
      return 0;  
  }`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.单词排序').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义单词结构体
typedef struct {
    char word[21];
} Word;

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    return strcmp(((Word *)a)->word, ((Word *)b)->word);
}

int main() {
    int n, i, order;
    
    // 输入单词数量和排序方式
    scanf("%d", &n);
    
    // 动态分配内存以存储单词数组
    Word *words = (Word *)malloc(n * sizeof(Word));
    
    // 输入单词
    for (i = 0; i < n; i++) {
        scanf("%s", words[i].word);
    }
    
    // 输入排序方式
    scanf("%d", &order);
    
    // 根据排序方式调用qsort进行排序
    if (order == 1) {
        qsort(words, n, sizeof(Word), compare);
    } else if (order == 2) {
        qsort(words, n, sizeof(Word), compare);
        // 降序排序的话，反转数组
        for (i = 0; i < n / 2; i++) {
            Word temp = words[i];
            words[i] = words[n - i - 1];
            words[n - i - 1] = temp;
        }
    }
    
    // 输出排序后的单词
    for (i = 0; i < n; i++) {
        printf("%s\n", words[i].word);
    }
    
    // 释放动态分配的内存
    free(words);
    
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.分类统计各类字符数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <ctype.h>

int main() {
    char str[1001];
    int upper = 0, lower = 0, digit = 0, space = 0, others = 0;

    fgets(str, sizeof(str), stdin);
    
    // 统计各类字符数
    for (int i = 0; str[i] != '\0'; ++i) {
        if (isupper(str[i])) {
            upper++;
        } else if (islower(str[i])) {
            lower++;
        } else if (isdigit(str[i])) {
            digit++;
        } else if (isspace(str[i])) {
            space++;
        } else {
            others++;
        }
    }
    
    // 输出统计结果
    printf("Uppercase: %d\n", upper);
    printf("Lowercase: %d\n", lower);
    printf("Digit: %d\n", digit);
    printf("Space: %d\n", space);
    printf("Others: %d\n", others);
    
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.孤独的素数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>  
#include <stdbool.h>  
  
#define MAX_N 50  
#define MAX_M 50  
  
bool isPrime(int num) {  
    if (num <= 1) return false;  
    if (num == 2) return true;  
    if (num % 2 == 0) return false;  
    for (int i = 3; i * i <= num; i += 2) {  
        if (num % i == 0) return false;  
    }  
    return true;  
}  
  
int countLonelyPrimes(int matrix[MAX_N][MAX_M], int n, int m) {  
    int count = 0;  
    for (int i = 0; i < n; i++) {  
        for (int j = 0; j < m; j++) {  
            if (isPrime(matrix[i][j])) {  
                bool lonely = true;  
                // Check top  
                if (i > 0 && isPrime(matrix[i - 1][j])) lonely = false;  
                // Check bottom  
                if (i < n - 1 && isPrime(matrix[i + 1][j])) lonely = false;  
                // Check left  
                if (j > 0 && isPrime(matrix[i][j - 1])) lonely = false;  
                // Check right  
                if (j < m - 1 && isPrime(matrix[i][j + 1])) lonely = false;  
                // Check top-left  
                if (i > 0 && j > 0 && isPrime(matrix[i - 1][j - 1])) lonely = false;  
                // Check top-right  
                if (i > 0 && j < m - 1 && isPrime(matrix[i - 1][j + 1])) lonely = false;  
                // Check bottom-left  
                if (i < n - 1 && j > 0 && isPrime(matrix[i + 1][j - 1])) lonely = false;  
                // Check bottom-right  
                if (i < n - 1 && j < m - 1 && isPrime(matrix[i + 1][j + 1])) lonely = false;  
                  
                if (lonely) {  
                    count++;  
                }  
            }  
        }  
    }  
    return count;  
}  
  
int main() {  
    int n, m;  
    scanf("%d %d", &n, &m);  
      
    int matrix[MAX_N][MAX_M];  
    for (int i = 0; i < n; i++) {  
        for (int j = 0; j < m; j++) {  
            scanf("%d", &matrix[i][j]);  
        }  
    }  
      
    int lonelyPrimesCount = countLonelyPrimes(matrix, n, m);  
    printf("%d\n", lonelyPrimesCount);  
      
    return 0;  
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.交换最小值和最大值').addEventListener('click', () => {
        const textToCopy = `#include<stdio.h>
int main()
{
    int i,j,min,max,n,tmp;
    scanf("%d",&n);
    int arr[n];
    for(i=0;i<n;i++)
        scanf("%d ",&arr[i]);
    min=max=arr[0];
    for(i=0;i<n;i++)
    {
        if(min>arr[i])
        {
            min=arr[i];
            j=i;
        }
    }
    tmp=arr[0];
    arr[0]=min;
    arr[j]=tmp;
    for(i=0;i<n;i++)
    {
        if(max<arr[i])
        {
            max=arr[i];
            j=i;
        }
    }
    tmp=arr[n-1];
    arr[n-1]=max;
    arr[j]=tmp;
    for(i=0;i<n;i++)
        printf("%d ",arr[i]);
    return 0;
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.数字提取').addEventListener('click', () => {
        const textToCopy = `#include<stdio.h>
#include<math.h>
int kk(long long int count)//定义函数kk，用于判断count是否为素数 
{
    if (count<2) return 0;//如果count小于2，则不是素数，返回0 
    for (long long int i=2;i<=sqrt(count);i++)//从2到count的平方根遍历
    {
        if (count%i==0)//如果count能被i整除，则不是素数 
            return 0;      
    }
    return 1;
}
int ss(long long int count)//定义函数ss，用于判断count是否为回文数
{
    long long int digit=0,a=count;//声明变量digit用于存储反转后的数字，a用于临时存储count的值
    while(a) // 循环直到a为0
    {
        digit=digit*10+a%10;
            a/=10;
    }
    if(digit==count)
        return 0;
    else
        return 1;
}
int main()
{
    char yy[60];
    long long int count=0,i;//声明count用于存储转换后的数字，i用于循环计数
    gets(yy);
    for(i=0;yy[i]!='\0';i++)
    {
       if(yy[i]>='0'&&yy[i]<='9')
           count=count*10+yy[i]-'0';//将字符转换为数字并累加到count中
    }
    printf("%lld\n",count);
    if(kk(count)==1)//调用kk函数判断count是否为素数
        printf("YES\n");
    else
        printf("NO\n");
    if(ss(count)==0)//调用ss函数判断count是否为回文数
        printf("YES");
    else
        printf("NO");
    return 0;
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.数组逆序').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

int main() {
    int n;
    // 读取整数个数
    scanf("%d", &n);
    
    // 创建一个数组来存储这些整数
    int numbers[n];
    
    // 读取n个整数并存储到数组中
    for(int i = 0; i < n; i++) {
        scanf("%d", &numbers[i]);
    }
    
    // 逆序输出这些整数
    for(int i = n - 1; i >= 0; i--) {
        printf("%d ", numbers[i]);
    }
    
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.鲜花方阵').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>  
  
  #define MAX_SIZE 100 // 假设n的最大值为100，您可以根据需要调整这个值  
    
  int main() {  
      int n, i, j;  
      scanf("%d", &n);  
    
      // 检查n是否在允许的范围内  
      if (n <= 0 || n > MAX_SIZE) {  
          printf("Size out of range!\n");  
          return 1;  
      }  
    
      int a[MAX_SIZE][MAX_SIZE]; // 使用固定大小的数组  
    
      for (i = 0; i < n; i++) {  
          for (j = 0; j < n; j++) {  
              a[i][j] = 1;  
    
              // 设置中心元素为0  
              if (i == n / 2 && j == n / 2) {  
                  a[i][j] = 0;  
              }  
    
              // 设置对角线及反对角线元素为0  
              if (i + j == n / 2 || i - j == n / 2 || j - i == n / 2 || i + j == (n / 2 - 1 + n)) {  
                  a[i][j] = 0;  
              }  
    
              printf("%3d", a[i][j]); // 打印每个元素，格式化输出宽度为3  
          }  
          printf("\n"); // 每行打印完后换行  
      }  
    
      return 0;  
  }`
        navigator.clipboard.writeText(textToCopy)
    })

    // 实战4-2
    document.querySelector('.查找最小的K个元素').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <stdlib.h>

// 定义比较函数，用于qsort排序
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int n, k;
    scanf("%d %d", &n, &k);

    // 读取n个整数
    int *nums = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        scanf("%d", &nums[i]);
    }

    // 对数组进行排序
    qsort(nums, n, sizeof(int), compare);

    // 输出最小的k个数字
    for (int i = 0; i < k; i++) {
        printf("%d ", nums[i]);
    }

    free(nums); // 释放动态分配的内存
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.矩阵字符').addEventListener('click', () => {
        const textToCopy = `#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const int N=1e3+10;
int main(){
    int i,m;
    string s1;
    cin>>s1;
    int len=s1.size();
    int c=sqrt(len);
    while(len%c)
        c--;
    int j=len/c;
    for(i=0;i<j;i++)
        for(m=i;m<len;m+=j)
            cout<<s1[m];
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.排队游戏').addEventListener('click', () => {
        const textToCopy = `#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<long long,int>pii;
vector<pii>v[1010];
bool flag[1010];
int main(){
    int n,i,j;
    long long num;
    cin>>n;
    for(i=1;i<=n;i++){
        flag[i]=1;
        for(j=1;j<=n;j++){
            cin>>num;
            v[i].push_back({num,j});
        }
    }
    for(i=1;i<=n;i++){
        sort(v[i].begin(),v[i].end());
    }
    int fp=0;
    while(fp<n-1){
        for(i=1;i<=n;i++){
            if(flag[i]!=0){
                int a=1;
                while(a<n){
                    if(flag[v[i][a].second]!=0){
                        flag[v[i][a].second]=0;
                        fp++;
                        break;
                    }
                    else{
                        a++;
                    }
                }
            }
        }
    }
    for(i=1;i<=n;i++){
if(flag[i]==1){
    cout<<i;
    break;
}}
    return 0;}

`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.蛇形填数').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

void snake_fill(int n) {
    int matrix[20][20] = {0}; // 最大支持20x20的方阵
    int num = 1;
    
    for (int i = 0; i < 2 * n - 1; i++) {
        if (i % 2 == 0) { // 偶数编号，从右上到左下填写
            int row = (i < n) ? i : n - 1;
            int col = (i < n) ? 0 : i - n + 1;
            while (row >= 0 && col < n) {
                matrix[row][col] = num;
                num++;
                row--;
                col++;
            }
        } else { // 奇数编号，从左下到右上填写
            int col = (i < n) ? i : n - 1;
            int row = (i < n) ? 0 : i - n + 1;
            while (col >= 0 && row < n) {
                matrix[row][col] = num;
                num++;
                col--;
                row++;
            }
        }
    }
    
    // 打印方阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%5d", matrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int n;
    scanf("%d", &n);
    snake_fill(n);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.数列元素去重并排序').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <stdlib.h>

// 比较函数用于排序
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int N;
    
    // 读取输入的N
    scanf("%d", &N);
    
    // 为存储数列元素的数组分配内存
    int *arr = (int*)malloc(N * sizeof(int));
    if (arr == NULL) {
        printf("内存分配失败\n");
        return 1;
    }
    
    // 读取N个数列元素
    for (int i = 0; i < N; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 对数组进行排序
    qsort(arr, N, sizeof(int), compare);
    
    // 输出排序后的数组，去重
    printf("%d ", arr[0]);
    for (int i = 1; i < N; i++) {
        if (arr[i] != arr[i - 1]) {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");
    
    // 释放动态分配的内存
    free(arr);
    
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.约瑟夫游戏111').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
int main(){
int a[101],b[101];
    int n,m,fp,num;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        a[i]=1;//定义一个数组将没出去的人定义为1
    }
    for(int i=0;i<n;i++){
scanf("%d",&b[i]);
    }
    m=num=fp=0;
    //以上为输入和初始化
    while(fp<n){//跳出循环条件
        for(int i=0;i<n;i++){
    if(a[i]==1){
    num++;
    if(num==b[m]){
        a[i]=0;//将编号为i的人出圈
        printf("%d ",i+1);
        num=0;//重置num的值
        fp++;
        m=i;
    }
    }
        }
    }
    return 0;
    }
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.约瑟夫游戏（姓名）').addEventListener('click', () => {
        const textToCopy = `#include <iostream>
#include <string>
using namespace std;
string s[110];
int a[1000010];
int main(){
    int n,m,fp,num;
    scanf("%d%d",&n,&m);
    getchar();
    for(int i=1;i<=n;i++){
        getline(cin,s[i]);
        a[i]=1;
    }
    num=fp=0;
    while(fp<n-1){
        for(int i=1;i<=n;i++){
            if(a[i]==1){
                num++;
                if(num==m){
                    a[i]=0;
                    num=0;
                    fp++;
                    cout<<s[i]<<endl;
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
if(a[i]==1){
    cout<<s[i];
    break;
}
    }
    printf("\n");
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.约瑟夫游戏').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>

// 定义循环链表的节点
struct Node {
    int data;
    struct Node* next;
};

// 创建一个循环链表
struct Node* createCircularLinkedList(int n) {
    struct Node* head = NULL;
    struct Node* prev = NULL;
    for (int i = 1; i <= n; ++i) {
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode->data = i;
        newNode->next = NULL;
        if (head == NULL) {
            head = newNode;
        } else {
            prev->next = newNode;
        }
        prev = newNode;
    }
    prev->next = head; // 将链表首尾相连，形成循环
    return head;
}

// 模拟约瑟夫游戏
int josephus(int n, int k) {
    struct Node* head = createCircularLinkedList(n);
    struct Node* curr = head;
    struct Node* prev = NULL;
    while (n > 1) {
        for (int i = 0; i < k - 1; ++i) {
            prev = curr;
            curr = curr->next;
        }
        prev->next = curr->next;
        struct Node* temp = curr->next;
        free(curr);
        curr = temp;
        --n;
    }
    int survivor = curr->data;
    free(curr);
    return survivor;
}

int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    int survivor = josephus(n, k);
    printf("%d\n", survivor);
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.字符串移位包含问题').addEventListener('click', () => {
        const textToCopy = `#include<iostream>
#include<algorithm>
#include<string>
using namespace std;;

const int N=1e3+10;
int main(){
    int i;
    string s1,s2;
    cin>>s1>>s2;
    int len1=s1.size();
    int len2=s2.size();
    if(!len1||!len2)
    {
        cout<<"false";
        return 0;
    }
    if(len2>len1)
    {
        string tp=s2;
        s2=s1;
        s1=tp;
    }
    s1+=s1;
    int it=s1.find(s2);
    if(it!=-1)
    {
        cout<<"true";
        return 0;
    }
    cout<<"false";
    return 0;
}
`
        navigator.clipboard.writeText(textToCopy)
    })

    // 实战5
    document.querySelector('.排队点名').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <stdlib.h>

// 双向链表节点结构体
typedef struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
} Node;

// 双向链表结构体
typedef struct {
    Node *head;
    Node *tail;
    int size;
} LinkedList;

// 初始化双向链表
void initList(LinkedList *list) {
    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
}

// 在链表头部插入节点
void insertFront(LinkedList *list, int data) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = list->head;

    if (list->head != NULL) {
        list->head->prev = newNode;
    } else {
        list->tail = newNode;
    }

    list->head = newNode;
    list->size++;
}

// 在链表尾部插入节点
void insertBack(LinkedList *list, int data) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->prev = list->tail;
    newNode->next = NULL;

    if (list->tail != NULL) {
        list->tail->next = newNode;
    } else {
        list->head = newNode;
    }

    list->tail = newNode;
    list->size++;
}

// 删除链表中指定节点
void deleteNode(LinkedList *list, Node *node) {
    if (node->prev != NULL) {
        node->prev->next = node->next;
    } else {
        list->head = node->next;
    }

    if (node->next != NULL) {
        node->next->prev = node->prev;
    } else {
        list->tail = node->prev;
    }

    free(node);
    list->size--;
}

// 输出链表元素
void printList(LinkedList *list) {
    Node *curr = list->head;
    while (curr != NULL) {
        printf("%d", curr->data);  // 输出当前节点的数据
        if (curr->next != NULL) {  // 如果当前节点不是最后一个节点，则输出空格
            printf(" ");
        }
        curr = curr->next;  // 移动到下一个节点
    }
    printf("\n");  // 输出换行
}

int main() {
    int n, m;
    scanf("%d", &n);

    LinkedList list;
    initList(&list);

    // 初始化队列
    for (int i = 0; i < n; i++) {
        int num;
        scanf("%d", &num);
        insertBack(&list, num);
    }

    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        int num;
        scanf("%d", &num);

        Node *curr = list.head;
        while (curr != NULL && curr->data != num) {
            curr = curr->next;
        }

        if (curr != NULL) {
            deleteNode(&list, curr);
            insertFront(&list, num);
        }
    }

    printList(&list);

    return 0;
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.期末考试成绩排名').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <string.h>

struct Student {
    int id;
    char name[21];
    int score;
};

int desc(const void *a, const void *b) {
    struct Student *studentA = (struct Student *)a;
    struct Student *studentB = (struct Student *)b;

    if (studentA->score != studentB->score) {
        return studentB->score - studentA->score;
    } else {
        return studentA->id - studentB->id;
    }
}

int main() {
    int n;
    scanf("%d", &n);

    struct Student students[n];

    for (int i = 0; i < n; i++) {
        scanf("%d %s %d", &students[i].id, students[i].name, &students[i].score);
    }

    qsort(students, n, sizeof(struct Student), desc);

    for (int i = 0; i < n; i++) {
        printf("%d %s %d\n", students[i].id, students[i].name, students[i].score);
    }

    return 0;
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.新生舞会').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <string.h>

struct Student {
    char name[21];
    char id[11];
    char gender;
};

int main() {
    int n, m;
    scanf("%d", &n);

    struct Student students[n];
    for (int i = 0; i < n; i++) {
        scanf("%s %s %c", students[i].name, students[i].id, &students[i].gender);
    }

    scanf("%d", &m);

    for (int i = 0; i < m; i++) {
        char info1[21], info2[21];
        scanf("%s %s", info1, info2);

        int index1 = -1, index2 = -1;

        for (int j = 0; j < n; j++) {
            if (strcmp(info1, students[j].name) == 0 || strcmp(info1, students[j].id) == 0) {
                index1 = j;
                break;
            }
        }

        for (int j = 0; j < n; j++) {
            if (strcmp(info2, students[j].name) == 0 || strcmp(info2, students[j].id) == 0) {
                index2 = j;
                break;
            }
        }

        if (index1 != -1 && index2 != -1 && students[index1].gender != students[index2].gender) {
            printf("Y\n");
        } else {
            printf("N\n");
        }
    }

    return 0;
}`
        navigator.clipboard.writeText(textToCopy)
    })
    document.querySelector('.约瑟夫游戏222').addEventListener('click', () => {
        const textToCopy = `#include <stdio.h>
#include <string.h>

#define MAX_PEOPLE 30
#define MAX_NAME_LENGTH 21

typedef struct {
    char name[MAX_NAME_LENGTH];
    int password;
} Person;

// 函数原型
void josephus(Person *, int, int);

int main() {
    int N, M;
    Person people[MAX_PEOPLE];

    // 输入参与游戏的人数
    scanf("%d", &N);

    // 输入每个人的姓名和密码
    for (int i = 0; i < N; i++) {
        scanf("%s %d", people[i].name, &people[i].password);
    }

    // 输入初始密码
    scanf("%d", &M);

    // 调用函数进行约瑟夫环处理
    josephus(people, N, M);

    return 0;
}

// 约瑟夫环函数
void josephus(Person *people, int N, int M) {
    int idx = 0;
    int cnt = 0;
    int outCount = 0;
    int isOut[MAX_PEOPLE] = {0};

    while (outCount < N) {
        // 找下一个还在圈里的人
        while (isOut[idx]) {
            idx = (idx + 1) % N;
        }

        // 计算出局人的位置
        int step = 0;
        while (step < M) {
            if (!isOut[idx]) {
                step++;
            }
            if (step < M) {
                idx = (idx + 1) % N; // 下一个位置
            }
        }

        // 输出出局人的姓名和编号
        printf("%d %s\n", idx + 1, people[idx].name);

        // 更新 M 为当前出局人的密码
        M = people[idx].password;

        // 标记出局
        isOut[idx] = 1;
        outCount++;
    }
}`
        navigator.clipboard.writeText(textToCopy)
    })

</script>

</html>